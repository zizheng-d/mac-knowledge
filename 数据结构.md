### 一、数据结构和算法



#### 1. 数据结构

​	数据结构是**计算机存储、组织数据**的方式。数据结构是指相互之间存在一种或多种特定关系的**数据元素**的集合。通常情况下，选择正确的数据结构可以带来更高的运行效率和存储效率。数据结构往往同高效的检索算法和索引技术有关。

​	数据结构演示地址：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

​	常见的数据结构如下：线性数据结构（数组、队列、链表、栈等）、非线性数据结构（）



##### 1.1 线性数据结构

###### 1.1.1 数组（Array）

​	数组（Array）是一种线性表数据结构，它用于存储具有固定大小的相同类型的数据元素。在数组中，数据元素按照有序的方式进行排列，可以通过索引访问任意位置的元素。

```java
// Java中创建数组的方式
// 动态初始化，初始化时程序员指定长度。由系统为数组分配初始值。
char c1[] = new char[5];
// 静态初始化，初始化时程序员指定默认值。由系统指定长度。
char c2[] = new char[]{'a','b','c'};
char c3[] = {'a','b','c'};
```

​	数组的特点：
1. **顺序存储**：数组中的元素按照顺序存储在连续的内存空间中，每个元素都有一个唯一索引，可以通过索引快速访问。
1. **大小固定**：一旦定义了数组的大小，就不能改变。如果需要更大的数组，则需要重新创建数组。
1. **元素类型相同**：数组中的所有元素必须是相同的数据类型。
1. **无界数组**：数组的长度可以是任意正整数，只要内存空间足够。

​	数组的优点：

1. **易于实现**
2. **访问速度快**：因为数组是**顺序存储**，可以通过索引快速访问数组中的元素。时间复杂度为**O(1)**。

​	数组的缺点：

1. **大小固定**：数组的大小是固定的，如果需要更多的数组空间，则需要重新创建数组，这样会带来额外的开销。
2. **空间利用率低**：因为数组中的元素是**按照顺序存储在连续的内存空间中**。所以在数组中，即便某些内存空间未被使用，也不能被其他数据结构使用。导致空间利用率较低。

###### 1.1.2 队列（Queue）

​	队列（Queue）是一种特殊的数据结构，其特点是遵循先进先出（FIFO）的原则。队列中的元素只能从一端（队尾）添加，从另一端（队头）删除。

```java
// Java中创建队列的方式之一
public static void main(String[] args){
    Queue<String> queue = new LinkedList();
    queue.offer("3");
    queue.offer("6");
    queue.offer("9");
    queue.offer("12");
    System.out.println(queue);// 打印队列中的所有元素
    System.out.println(queue.peek());// 访问队列头元素
    System.out.println(queue);// 打印队列中的所有元素
    System.out.println(queue.poll());// 访问队列尾元素
    System.out.println(queue);// 打印队列中的所有元素
}
```

​	队列的特点：

1. 先进先出：队列中的元素遵循先进先出（FIFO）的原则。即最早进入队列的元素最先被删除。
2. **一端进，一端出**：队列有两个主要的操作端点，分别称为队尾（rear）和队头（front）。新元素从队尾加入队列，而已有元素则从队头被移除。这种设计保证了队列操作的顺序性和高效性。
3. 无界队列：队列的长度可以是任意正整数，只要内存空间足够。

###### 1.1.3 链表（Linked）

​	链表（Linked）是一种常见的线性数据结构，它通过指针将一组零散的内存块串联在一起，链表中每个内存块都被称为节点，每个节点除了存储数据之外，还需要记录下一个节点的地址。

​	链表的特点：

1. 不需要连续的内存空间
2. 有指针引用
3. 插入、删除效率高，时间复杂度为O(1)，仅需要修改指针的地址即可。但是，随机访问效率低，时间复杂度为O(n)。需要从链头至链尾进行遍历。

​	链表包括单向链表、双向链表和循环链表等类型。其中，单向链表只有一个后继指针next指向下一个节点。双向链表的节点除了有一个后继指针指向下一个节点，还有一个前驱指针指向前面的节点。循环链表和单向链表唯一的区别是尾节点的指针指向头节点，形成一个环。

###### 1.1.4 栈（Stack）

​	栈（Stack）是一种后进先出（LIFO）的数据结构，它只能在一端进行插入和删除。这一端称为栈顶，另一端称为栈底。栈的元素之间存在一种顺序关系，这种顺序关系由元素的插入和删除操作而决定。

​	栈的特点：

1. 后进先出（LIFO）
1. 无界队列：长度可以是任意正整数，只要内存空间足够。



##### 1.2 非线性数据结构

​	在非线性数据结构中，数据之间并不是简单的前后关系。非线性结构是一种相对复杂的数据结构，它不满足线性结构的数据元素之间的一对一关系，而是满足多对多的关系（这种关系可以通过指针、引用等方式来实现），它可以用来表示复杂的数据关系，如：网络关系、图形关系等

​	非线性结构包括：图结构、数结构、二维数组、广义表、多位数组等。

###### 1.2.1 树（Tree）

​	树是n个结点的有限集合，当n=0时，我们称之为空树。在树中需要注意的是，根结点有且仅有一个，其下的子树没有个数限制，但他们一定是互不相交的。所以，任意一个非空树都具有一下特点：

1. 有且仅有一个特定的根节点[root]
2. 当n>1时，其余的结点可分为m(m>0)个互不相交的有限集。其中每个集合本身又是一棵树，我们称之为子树。

​	如图，是一颗普通的树（画图使用的是mermaid，语法：[mermaid中文网][url1]）：

```mermaid
graph TD
	A((A))
	B((B))
  C((C))
  D((D))
  E((E))
  F((F))
  G((G))
  H((H))
  I((I))

  A --- B 
  A --- C
	B --- D
	B --- E
	B --- F
	C --- G
	C --- H
	C --- I
```

​	在树中结点拥有的子树数目称为结点的**度**，如上图，A结点的度数为2，B和C结点的度数为3，D、E、F、G、H、I的度数为0。同时树的也拥有层次的概念，如上图：A结点所在为第1层，B、C结点所在为第二层依次类推。层数最大的层称之为树的**深度**，如上图树的深度为3。

​	根据不同的分类方式，树可以分为不同的类型：

1. 根据树分支的数量限制，可以分为二叉树和多叉树。二叉树每个结点最多只能拥有两个子结点。而多叉树每个结点可以有多余两个的子结点。
2. 根据树结点的有序性，可以分为查找树和无序树。查找树的基本特征为，任意一个结点所对应的值大于等于左子结点对应的值。小于等于右子结点对应的值。无序树则没有特定的大小关系。
3. 根据具体用途和特征，如：红黑树、AVL树、平衡二叉树、平衡二叉搜索树等。红黑树是一种自平衡二叉查找树。AVL树也是一种自平衡二叉查找树，它要求任何节点的两个子树的高度差最大为1，平衡二叉树和平衡二叉搜索树则为是为了平衡树的左右子树的高度差。
4. 根据树的完整性和是否包含空值：可以分为完全二叉树、满二叉树、完全二叉搜索树、满二叉搜索树等。完全二叉树和满二叉搜索树是包含所有节点的二叉树，而完全二叉搜索树和满二叉搜索树则是所有节点都按照一定的顺序排列的二叉搜索树。

###### 1.2.2 二叉树

​	二叉树是指：每个子结点只有两个结点的树，每个结点之多拥有两棵子树（即：二叉树中不存在度大于2的结点）。并且二叉树的子树有左右之分，其次序不可以任意颠倒。

​	如下图，是一棵二叉树：

```mermaid
graph TD
A((4))
B((2))
C((6))
D((1))
E((3))
F((5))
G((7))

A --- B
A --- C
B --- D
B --- E
C --- F
C --- G

```

​	**二叉查找树**又称为有序二叉查找树，它具有以下性质：

		1. 任意结点的左子结点不为空，并且左子结点的值均小于根结点的值。
		1. 任意结点的右子结点不为空，并且右子结点的值均大于根节点的值。
		1. 任意结点的左右子结点也分别是二叉树。
		1. 值不可以相同。

​	二叉树又分为：完美二叉树、完全二叉树、完满二叉树。

1. 完美二叉树：又称为满二叉树，除了叶子结点之外每一个结点都有两个字结点。每层都被完全填充。如下图：

   ```mermaid
   graph TD
   A((4))
   B((2))
   C((6))
   D((1))
   E((3))
   F((5))
   G((7))
   
   A --- B
   A --- C
   B --- D
   B --- E
   C --- F
   C --- G
   
   ```

   

2. 完全二叉树：除了叶子结点之外的其他每一层都被完全填充，并且所有的结点都保持向左对齐。如下图：

   ```mermaid
   graph TD
   %%A((1))
   %%B((2))
   %%C((3))
   %%D((4))
   %%E((5))
   %%F((6))
   %%G((7))
   %%H((8))
   %%I((9))
   
   A1((1))
   B1((2))
   C1((3))
   D1((4))
   E1((5))
   F1((6))
   G1((7))
   H1((8))
   I1((9))
   
   A1 --- B1
   A1 --- C1
   B1 --- D1
   B1 --- E1
   C1 --- F1
   C1 --- G1
   D1 --- H1
   D1 --- I1
   
   %%E --- D
   %%D --- B
   %%D --- C
   %%B --- A
   %%E --- H
   %%H --- G
   %%H --- I
   %%G --- F
   ```

   

3. 完满二叉树：除了叶子结点之外，每个结点都有两个孩子结点

   ```mermaid
   graph TD
   1((1))
   2((2))
   3((3))
   4((4))
   5((5))
   6((6))
   7((7))
   8((8))
   9((9))
   
   1 --- 2
   1 --- 3
   2 --- 4
   2 --- 5
   3 --- 6
   3 --- 7
   5 --- 8
   5 --- 9
   ```

​	二叉树的遍历规则有如下三种：

1. 中序遍历：先访问左结点，再访问根节点，最后访问右结点。即左-根-右
2. 先序遍历：先访问根节点，再访问左结点，最后访问右结点。即根-左-右
3. 后序遍历：先访问左结点，再反问右结点，最后访问根节点。即左-右-根

```mermaid
graph TD
A((4.0))
B((2.0))
C((6.0))
D((1.0))
E((3.0))
F((5.0))
G((7.0))
A1((2.5))
A2((5.5))
A3((X))
A4((X))

A --- B
A --- C
B --- D
B --- E
C --- F
C --- G
E --- A1
E -.- A3
F -.- A4
F --- A2

```

​	如上图（图中的x结点为不存在的结点），不同的遍历规则，读出来的数据不同：

1. 中序遍历结果：1，2，2.5，3，4，5，5.5，6，7
2. 先序遍历结果：4，2，1，3，2.5，6，5，5.5，7
3. 后序遍历结果：1，2.5，3，2，5.5，5，7，6，4

​	对于二叉查找树来说，存在一些特殊的查找：

1. 查找最小值：沿着根结点的左子树一路查找，直到最后一个不为空的结点。
2. 查找最大值：沿着根结点的右子树一路查找，直到最后一个不为空的结点。

​	前驱结点和后驱结点的概念，在链表中是指某个结点的前一个结点和后一个结点。在二叉搜索树中，要查找某个结点的前驱或者后驱结点，则需要按照**中序遍历**后位于该结点前和后的结点分别是前驱结点和后驱结点。对于搜索二叉树的中序遍历来说，可以将树中所有的值按照数据进行读取，在此基础上我们可以梳理出快速查找前驱/后驱结点的方法。

1. 前驱结点：当前结点左子树中值最大的结点。

2. 后驱结点：当前结点右子树中值最小的结点。

   如下图：结点4.0的前驱结点为：3.0，后驱结点为：5.0，结点6.0的前驱结点为5.5，后驱结点为7。（中序遍历结果为：1，2，2.5，3，4，5，5.5，6，7）

   ```mermaid
   graph TD
   A((4.0))
   B((2.0))
   C((6.0))
   D((1.0))
   E((3.0))
   F((5.0))
   G((7.0))
   A1((2.5))
   A2((5.5))
   A3((X))
   A4((X))
   
   A --- B
   A --- C
   B --- D
   B --- E
   C --- F
   C --- G
   E --- A1
   E -.- A3
   F -.- A4
   F --- A2
   
   ```

​	









[url1]: https://mermaid.nodejs.cn/intro/
